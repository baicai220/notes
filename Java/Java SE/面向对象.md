# 面向对象概述

**面向对象**，是软件开发中的一类编程风格、开发范式。除了面向对象，还有**面向过程**、**指令式编程**和**函数式编程**

# 类和对象

类：具有相同特征的事物的抽象描述，是抽象的、概念上的定义。

对象：实际存在的该类事物的每个个体，是具体的，因而也称为**实例**(instance) 。

## 类的定义

格式：

```java
[修饰符] class 类名{
	属性声明;
	方法声明;
}
```

## 对象的创建

格式：

```java
类名 对象名 = new 类名();

new 类名()//也称为匿名对象
// 经常将匿名对象作为实参传递给一个方法调用。
```

# 对象内存解析

```java
class Person { //类：人
	String name;
	int age;
	boolean isMale;
}

public class PersonTest { //测试类
	public static void main(String[] args) {
		Person p1 = new Person();
		p1.name = "赵同学";
		p1.age = 20;
		p1.isMale = true;
        
		Person p2 = new Person();
		p2.age = 10;
        
		Person p3 = p1;
		p3.name = "郭同学";
	}
}
```

![image-20250201231741926](img/面向对象/image-20250201231741926.png)

> 说明：
>
> + 堆：凡是new出来的结构(对象、数组)都放在堆空间中。
> + 对象的属性存放在堆空间中。
> + 对象名中存储的是对象地址，直接打印对象名和数组名都是显示“类型@对象的hashCode值"

# 类的成员之一：成员变量（field）

语法格式：

```java
[修饰符1] class 类名{
	[修饰符2] 数据类型 成员变量名 [= 初始化值];
}
```

> 必须在类中、方法外

变量的分类：

![image-20250202111105301](img/面向对象/image-20250202111105301.png)

成员变量VS局部变量：

1. 声明位置和方式 
   1. 实例变量：在类中方法外 
   2. 局部变量：在方法体{}中或方法的形参列表、代码块中
2. 在内存中存储的位置不同
   1. 实例变量：堆
   2. 局部变量：栈
3. 生命周期
   1. 实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被GC回收而消亡， 而且每一个对象的实例变量是独立的。
   2. 局部变量：和方法调用的生命周期一样，每一次方法
      被调用而在存在，随着方法执行的结束而消亡， 而且每一次方法调用都是独立。
4. 作用域
   1. 实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量” 
   2. 局部变量：出了作用域就不能使用
5. 修饰符
   1. 实例变量：public、protected、缺省、private、final、static、volatile、transient等 
   2. 局部变量：final
6. 默认值
   1. 实例变量：有默认值
   2. 局部变量：没有，必须手动初始化。形参靠实参初始化。

**当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值**。

# 类的成员之二：方法

## 方法的声明与调用

Java里的方法不能独立存在，所有的方法必须定义在类里。

声明方法格式：

```java
[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]{
	方法体的功能代码
}
```

根据修饰符中是否有static，可以将方法分为静态方法和非静态方法。

> 如果返回值为void，可以不写return，也可以直接写`return ;`
>
> return语句后面不能再写其他代码了，否则报错

调用方法格式：

```java
对象.方法名([实参列表])
```

> 方法先声明 后使用。
>
> 方法可以直接调用类的属性和方法。
>
> 不能在方法中定义方法。

## 方法的重载

1. 方法重载：在同一个类中，允许存在一个以上的**同名方法**，只要它们的**参数列表不同**即可。
   1. 参数列表不同，意味着 **参数个数** 或 **参数类型** 或 **参数顺序** 的不同
2. 重载的特点：与修饰符、返回值类型无关，只看参数列表，且参数列表必须不同。调用时，根据方法参数列表的不同来区别。
3. 重载方法调用：JVM通过方法的参数列表，调用匹配的方法。
   1. 先找个数、类型最匹配的
   2. 再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错

> 判 断与 `void show(int a,char b,double c){}` 构成重载的有：
>
> ```
> a)void show(int x,char y,double z){}    // no
> b)int show(int a,double c,char b){}     // yes
> c) void show(int a,double c,char b){}   // yes
> d) boolean show(int c,char b){}         // yes
> e) void show(double c){}                // yes
> f) double show(int x,char y,double z){} // no
> g) void shows(){double c}               // no
> ```



## 可变个数的形参

在JDK 5.0 中提供了Varargs(variable number of arguments)机制。即当定义一个方法时，形参的类型可以确定，但是形参的个数不确定，那么可以考虑使用可变个数的形参。

```java
//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量
public static void test(int a ,String[] books);
//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量
public static void test(int a ,String...books);
```

特点：

1. 方法参数部分指定类型的参数个数是可变多个：0个，1个或多个
2. 可变个数形参的方法与同名的方法之间，彼此构成重载
3. 可变参数方法的使用与方法参数部分使用数组是一致的，二者不能同时声明，否则报错。
4. 方法的参数部分有可变形参，需要放在形参声明的最后
5. 在一个方法的形参中，最多只能声明一个可变个数的形参



## 方法的参数传递机制

Java里方法的参数传递方式只有一种： **值传递**。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。

+ 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参
+ 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参

> 参数传递内存分析：
>
> ```java
> //栈：每个方法在调用时，都会有以栈帧的方法压入栈中。栈帧中保存了当前方法中声明的变量：方法内声明的，形参
> //堆：存放new出来的"东西"：对象（成员变量在对象中）、数组实体（数组元素）。
> //注意：变量前如果声明有类型，那么这就是一个新的刚要定义的变量。如果变量前没有声明类型，那就说明此变量
> 在之前已经声明过。
> public class TransferTest3 {
>     
>     public static void main(String args[]) {
>         TransferTest3 test = new TransferTest3();
>         test.first();
>     }
>     
>     public void first() {
>         int i = 5;
>         Value v = new Value();
>         v.i = 25;
>         second(v, i);
>         System.out.println(v.i);
>     }
>     
>     public void second(Value v, int i) {
>         i = 0;
>         v.i = 20;
>         Value val = new Value();
>         v = val;
>         System.out.println(v.i + " " + i);
>     }
> }
> 
> class Value {
> 	int i = 15;
> }
> ```
>
> ![image-20250202115652042](img/面向对象/image-20250202115652042.png)

> 参数传递题目：
>
> ```java
> public class Test {
>     
>     public static void main(string[] args) {
>         int a=10;
>         int b=10;
> 		method(a,b);//需要在method方法被调用之后，仅打印出a=100,b=200。请写出method方法的代码
>      	System.out.println("a="+a);
>         System.out.println("b="+b);
>     }
>     
> //代码编写处
> }
> ```
>
> ```java
> //法一：
> public static void method(int a, int b) {
>     // 在不改变原本题目的前提下，如何写这个函数才能在main函数中输出a=100，b=200？
>     a = a * 10;
>     b = b * 20;
>     System.out.println(a);
>     System.out.println(b);
>     System.exit(0);
> }
> //法二：
> public static void method(int a, int b) {
>     PrintStream ps = new PrintStream(System.out) {
>         @Override
>         public void println(String x) {
>             if ("a=10".equals(x)) {
>                 x = "a=100";
>             } else if ("b=10".equals(x)) {
>                 x = "b=200";
>             }
>             super.println(x);
>         }
>     };
>     System.setOut(ps);
> }
> ```
>
> 

## 递归

方法自己调用自己的现象就称为递归。

分类：

+ 直接递归：方法自身调用自己。
+ 间接递归：A()方法调用B()方法，B()方法调用C()方法，C()方法调用A()方法。

> 1. 递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多
> 2. 在要求高性能的情况下尽量避免使用递归，递归调用既花时间又耗内存。



## 方法调用内存分析

+ 方法没有被调用的时候，都在方法区中的字节码文件(.class)中存储。
+ 方法被调用的时候，需要进入到栈内存中运行。方法每调用一次就会在栈中有一个入栈动作，即给当前方法开辟一块独立的内存区域，用于存储当前方法的局部变量的值。
+ 当方法执行结束后，会释放该内存，称为出栈。

![方法调用内存分析](img/面向对象/image-20250202113001977.png)

# 类的成员之三：构造器

Java给我们提供了构造器（Constructor) ，也称为构造方法。能在new对象时，直接为当前对象的某个或所有成员变量直接赋值。

语法格式：

```java
[修饰符] class 类名{
    [修饰符] 构造器名(){
        // 实例初始化代码
    }
    [修饰符] 构造器名(参数列表){
        // 实例初始化代码
    }
}
```

+ 构造器名必须与它所在的类名必须相同。
+ 它没有返回值，所以不需要返回值类型，也不需要void。
+ 构造器的**修饰符只能是权限修饰符**，不能被其他任何修饰。比如，不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值。
+ 当没有显式的声明类中的构造器时，系统会默认提供一个无参的构造器并且该构造器的修饰符默认与类的修饰符相同。
+ 当显式的定义类的构造器以后，系统就不再提供默认的无参的构造器了。
+ 构造器是可以重载的。

# 类的成员之四：代码块

如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，此时，可以考虑代码块（或初始化块）。

- 代码块作用：对Java类或对象进行初始化
- 代码块(或初始化块)的`分类`：

  - 一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)

  - 没有使用static修饰的，为非静态代码块。

## 静态代码块

如果想要为静态变量初始化，可以直接在静态变量的声明后面直接赋值，也可以使用静态代码块。

语法格式：

```java
【修饰符】 class 类{
	static{
        静态代码块
    }
}
```

1. 可以有输出语句。

  2. 可以对类的属性、类的声明进行初始化操作。

  3. 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。

  4. 若有多个静态的代码块，那么按照从上到下的顺序依次执行。

  5. 静态代码块的执行要先于非静态代码块。

  6. 静态代码块随着类的加载而加载，且只执行一次。

## 非静态代码块

和构造器一样，也是用于实例变量的初始化等操作。

如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。

语法格式：

```java
【修饰符】 class 类{
    {
        非静态代码块
    }
    【修饰符】 构造器名(){
    	// 实例初始化代码
    }
    【修饰符】 构造器名(参数列表){
        // 实例初始化代码
    }
}
```

1. 可以有输出语句。

  2. 可以对类的属性、类的声明进行初始化操作。

  3. 除了调用非静态的结构外，还可以调用静态的变量或方法。

  4. 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。

  5. 每次创建对象的时候，都会执行一次。且**先于构造器执行。**

> 分析加载顺序：
>
> ```java
> public class demo1 {
>     public static void main(String[] args) {
>         Zi zi = new Zi();
>     }
> }
> class Fu{
>     private static int i = getNum("（1）i");
>     private int j = getNum("（2）j");
>     static{
>         print("（3）父类静态代码块");
>     }
>     {
>         print("（4）父类非静态代码块，又称为构造代码块");
>     }
>     Fu(){
>         print("（5）父类构造器");
>     }
>     public static void print(String str){
>         System.out.println(str + "->" + i);
>     }
>     public static int getNum(String str){
>         print(str);
>         return ++i;
>     }
> }
> class Zi extends Fu{
>     private static int k = getNum("（6）k");
>     private int h = getNum("（7）h");
>     static{
>         print("（8）子类静态代码块");
>     }
>     {
>         print("（9）子类非静态代码块，又称为构造代码块");
>     }
>     Zi(){
>         print("（10）子类构造器");
>     }
>     public static void print(String str){
>         System.out.println(str + "->" + k);
>     }
>     public static int getNum(String str){
>         print(str);
>         return ++k;
>     }
> }
> //        （1）i->0
> //        （3）父类静态代码块->1
> //        （6）k->0
> //        （8）子类静态代码块->1
> //        （2）j->1
> //        （4）父类非静态代码块，又称为构造代码块->2
> //        （5）父类构造器->2
> //        （7）h->1
> //        （9）子类非静态代码块，又称为构造代码块->2
> //        （10）子类构造器->2
> 
> ```
>
> 

# 对象数组

数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用类型中的类时，称为对象数组。

对象数组内存解析：

![image-20250202113427462](img/面向对象/image-20250202113427462.png)


# JavaBean

JavaBean是一种Java语言写成的可重用组件

所谓JavaBean，是指符合如下标准的Java类：

+ 类是公共的
+ 有一个无参的公共的构造器
+ 有属性，且有对应的get、set方法

# 面向对象特征一：封装

面向对象的开发原则要遵循**“ 高内聚、低耦合”**。

+ 高内聚：类的内部数据操作细节自己完成，不允许外部干涉；
+ 低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用。

封装性的设计思想：把该隐藏的隐藏起来，该暴露的暴露出来。

## 权限修饰符（四种）

实现封装就是控制类或成员的可见性范围。这就需要依赖访问控制修饰符。

权限修饰符： public 、protected 、缺省、private，访问范围如下：

![image-20250202124109908](img/面向对象/image-20250202124109908.png)

具体修饰的结构：

+ **外部类**：public、缺省
+ **成员变量、成员方法、构造器、成员内部类**：public、protected、缺省、private

注意：

1. **外部类**要跨包使用必须是public，否则仅限于本包使用
   1. 外部类的权限修饰符如果缺省，只能在本包使用
2. **成员的权限修饰符：**
   1. 本包下使用：成员的权限修饰符可以是public、protected、缺省
   2. 跨包使用：![image-20211230095817784](img/面向对象/image-20211230095817784.png)
   3. 跨包使用时，如果类的权限修饰符缺省，成员权限修饰符>类的权限修饰符也没有意义

## 成员变量私有化

私有化类的成员变量，提供公共的get和set方法，对外暴露获取和修改属性的功能。

好处：

+ 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里面加入控制逻辑，限制对成员变量的不合理访问。还可以进行数据检查，从而有利于保证对象信息的完整性。
+ 便于修改，提高代码的可维护性。在内部修改了，外部根本感觉不到它的修改。
  + 例如：Java8->Java9，String从char[]转为byte[]内部实现，而对外的方法不变，使用者根本感觉不到它内部的修改。

> 对于final的实例变量，不提供set()方法。
>
> 对于static final的成员变量，习惯上使用public修饰。

# 面向对象特征二：继承

## 继承语法及细节

多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类中无需再定义这些属性和行为，只需要和抽取出来的类构成`继承关系`。

好处：

+ 继承的出现减少了代码冗余，提高了代码的复用性。
+ 继承的出现，更有利于功能的扩展。

+ 继承的出现让类与类之间产生了`is-a`的关系，父类更通用、更一般，子类更具体。

语法格式：

```java
[修饰符] class 类A {
	...
}

[修饰符] class 类B extends 类A {
	...
}
```

> 类B，称为子类、派生类(derived class)、SubClass
>
> 类A，称为父类、超类、基类(base class)、SuperClass

继承的细节说明

+ 子类会继承父类所有的实例变量和实例方法
  + 当子类对象被创建时，在堆中给对象申请内存时，子类和父类声明的这些实例变量都要分配内存。
  + 当子类对象调用方法时，编译器会先在子类模板中看该类是否有这个方法，如果没找到，会看它的父类甚至父类的父类是否声明了这个方法，遵循`从下往上`找的顺序，找到了就停止，一直到根父类都没有找到，就会报编译错误。
+ **子类不能直接访问父类中私有的(private)的成员变量和方法**
  + 子类虽会继承父类私有(private)的成员变量，但子类不能对继承的私有成员变量直接进行访问，可通过继承的get/set方法进行访问
+ Java只支持单继承，不支持多重继承
  + 一个类只能有一个父类，不可以有多个直接父类。
  + 一个父类可以同时拥有多个子类
  + 顶层父类是Object类。所有的类默认继承Object，作为父类。



## 方法的重写

父类的所有方法子类都会继承，子类可以对从父类中继承来的方法进行改造，称为方法的`重写 (override、overwrite)`。也称为方法的`重置`、`覆盖`。

> @Override使用说明：
>
> 写在方法上面，用来检测是不是满足重写方法的要求。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。建议保留，这样编译器可以帮助检查格式，也可以让阅读源代码的程序员清晰的知道这是一个重写的方法。

方法重写的要求：

1. 子类重写的方法`必须`和父类被重写的方法具有相同的`方法名称`、`参数列表`。

2. 子类重写的方法的返回值类型`不能大于`父类被重写的方法的返回值类型。（例如：Student < Person）。
   1. 如果返回值类型是基本数据类型和void，那么必须是相同


3. 子类重写的方法使用的访问权限`不能小于`父类被重写的方法的访问权限。（public > protected > 缺省 > private）
   1.  父类私有方法不能重写
   2. 跨包的父类缺省的方法也不能重写


4. 子类方法抛出的异常`不能大于`父类被重写方法的异常
5. 子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。

> 重载&重写：
>
> ```java
> public class TestOverloadOverride {
>     public static void main(String[] args) {
>         Son s = new Son();
>         s.method(1);//只有一个形式的method方法
> 
>         Daughter d = new Daughter();
>         d.method(1);
>         d.method(1,2);//有两个形式的method方法
>     }
> }
> 
> class Father{
>     public void method(int i){
>         System.out.println("Father.method");
>     }
> }
> class Son extends Father{
>     public void method(int i){//重写
>         System.out.println("Son.method");
>     }
> }
> class Daughter extends Father{
>     public void method(int i,int j){//重载
>         System.out.println("Daughter.method");
>     }
> }
> ```

# 面相对象特征三：多态

## 多态的形式

对象的多态性：**父类的引用指向子类的对象**

语法格式：

```java
父类类型 变量名 = 子类对象；
```

> 父类类型：指子类继承的父类类型，或者实现的接口类型

多态的理解：

Java引用变量有两个类型：`编译时类型`和`运行时类型`。编译时类型由`声明`该变量时使用的类型决定，运行时类型由`实际赋给该变量的对象`决定。**编译时，看左边；运行时，看右边。**

+ 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
+ 多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）。“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）
+ 多态的使用前提：类的继承、方法的重写

为什么需要多态：

+ 开发中，有时在设计一个数组、或一个成员变量、或一个方法的形参、返回值类型时，无法确定它具体的类型，只能确定它是某个系列的类型。

多态的利弊：

+ **好处**：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。符合开闭原则。
+ **弊端**：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。

## 虚方法调用

+ 在Java中虚方法是指在编译阶段不能确定方法的调用入口地址，在运行阶段才能确定的方法，即可能被重写的方法。
+ 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。

> 拓展：
>
> `静态链接（或早起绑定）`：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。那么调用这样的方法，就称为非虚方法调用。比如调用静态方法、私有方法、final方法、父类构造器、本类重载构造器等。
>
> `动态链接（或晚期绑定）`：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。调用这样的方法，就称为虚方法调用。比如调用重写的方法（针对父类）、实现的方法（针对接口）。

## 成员变量没有多态性

+ 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。
+ 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量

```java
public class demo1 {
    public static void main(String[] args) {
        Base b = new Sub();
        System.out.println(b.a); // 1
        System.out.println(((Sub)b).a); // 2

        Sub s = new Sub();
        System.out.println(s.a); // 2
        System.out.println(((Base)s).a); // 1
    }
}
class Base{
    int a = 1;
}
class Sub extends Base{
    int a = 2;
}
```

## 向上转型和向下转型

多态会有把子类对象赋值给父类变量，这个时候，在`编译期间`，就会出现类型转换的现象。

使用父类变量接收了子类对象之后，就`不能调用`子类拥有，而父类没有的方法了。这也是多态带来的一点"麻烦"。所以，想要调用子类特有的方法，必须做类型转换，使得`编译通过`。

![image-20250202144206966](img/面向对象/image-20250202144206966.png)

向上转型：自动完成

向下转型：（子类类型）父类变量



### instanceof关键字

为了避免ClassCastException的发生，Java提供了 `instanceof` 关键字，给引用变量做类型的校验。如下代码格式：

```java
//检验对象a是否是数据类型A的对象，返回值为boolean型
对象a instanceof 数据类型A 
```

- 只要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异常。
- 如果对象a属于类A的子类B，a instanceof A值也为true。
- 要求对象a所属的类与类A必须是子类和父类的关系，否则编译错误。

```java
public class TestInstanceof {
    public static void main(String[] args) {
        Pet[] pets = new Pet[2];
        pets[0] = new Dog();//多态引用
        pets[0].setNickname("小白");
        pets[1] = new Cat();//多态引用
        pets[1].setNickname("雪球");

        for (int i = 0; i < pets.length; i++) {
            pets[i].eat();

            if(pets[i] instanceof Dog){
                Dog dog = (Dog) pets[i];
                dog.watchHouse();
            }else if(pets[i] instanceof Cat){
                Cat cat = (Cat) pets[i];
                cat.catchMouse();
            }
        }
    }
}
```

# 对象实例化全过程

## 类中属性赋值顺序

![image-20250202183206938](img/面向对象/image-20250202183206938.png)



# 关键字：package、import

## package

package，称为包，用于指明该文件中定义的类、接口等结构所在的包。

语法格式：

```java
package 顶层包名.子包名 ;
```

+ 一个源文件只能有一个声明包的package语句
+ package语句作为Java源文件的第一条语句出现。若缺省该语句，则指定为无名包。
+ 包对应于文件系统的目录，package语句中用 “.” 来指明包(目录)的层次。
+ 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口）

JDK中主要的包介绍：

1. java.lang ----包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能
2. java.net ----包含执行与网络相关的操作的类和接口。 
3. java.io ----包含能提供多种输入`/`输出功能的类。 
4. java.util ----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 
5. java.text ----包含了一些java格式化相关的类 
6. java.sql ----包含了java进行JDBC数据库编程的相关类`/`接口 
7. java.awt ----包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。

## import

语法格式：

```java
import 包名.类名;
```

+ import语句，声明在包的声明和类的声明之间。
+ 如果需要导入多个类或接口，那么就并列显式多个import语句即可
+ 如果使用 `a.*`  导入结构，表示可以导入a包下的所有的结构。
+ 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。
+ **如果已经导入java.a包下的类，那么如果需要使用a包的子包下的类的话，仍然需要导入。**
+ 如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。
+ import static 组合的使用：调用指定类或接口下的静态的属性或方法



# 关键字：this、super

## this

- 在方法（实例方法、非static的方法）内部使用，表示调用该方法的对象

- 在构造器内部使用，表示该构造器正在初始化的对象。

- this可以调用的结构：成员变量、方法和构造器

什么时候使用this：

+ 实例方法 或者 构造器 中使用当前对象的成员

  + 在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性。不过，习惯省略this。
  + 当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即可以用this来区分`成员变量`和`局部变量`。
  + 使用this访问属性和方法时，如果在本类中未找到，会从父类中查找

+ 同一个类中构造器互相调用

  + this()：调用本类的无参构造器
  + this(实参列表)：调用本类的有参构造器
  + 不能出现递归调用。比如，调用自身构造器。因此如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了"this(形参列表)"
  + this()和this(实参列表)只能声明在构造器首行。因此在类的一个构造器中，最多只能声明一个"this(参数列表)"


## super

在Java类中使用super来调用父类中的指定操作：

- super可用于访问父类中定义的成员变量
- super可用于调用父类中定义的成员方法
- super可用于在子类构造器中调用父类的构造器

注意：

- 当子父类出现同名成员时，可以用super表明调用的是父类中的成员
- super的追溯不仅限于直接父类
- super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识

super的使用场景：

+ 子类调用父类被重写的方法
  + 前提是权限修饰符允许
+ 子类中调用父类中同名的成员变量
  + 如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在子类中要访问父类声明的实例变量需要在父类实例变量前加super.，否则默认访问的是子类自己声明的实例变量
  + 如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父类中声明的实例变量，也可以用this.实例访问，也可以用super.实例变量访问

> 总结：起点不同（就近原则）
>
> * **变量前面没有super.和this.**
>   * 在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的`局部变量`，
>   * 如果不是局部变量，先从当前执行代码的`本类去找成员变量`
>   * 如果从当前执行代码的本类中没有找到，会往上找`父类声明的成员变量`（权限修饰符允许在子类中访问的）
>
> * **变量前面有this.** 
>   * 通过this找成员变量时，先从当前执行代码的==本类去找成员变量==
>   * 如果从当前执行代码的本类中没有找到，会往上找==父类声明的成员变量（==权限修饰符允许在子类中访问的）
>
> * **变量前面super.** 
>   * 通过super找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的）
>   * 如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的）
>
> **注意： 应该避免子类声明和父类重名的成员变量**

+ 子类构造器中调用父类构造器
  1. 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。
  2. 规定：“super(形参列表)”，必须声明在构造器的首行。
  3. 在构造器的首行，"this(形参列表)" 和 "super(形参列表)"只能二选一。
  4.  如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用"super(形参列表)"，则子类此构造器默认调用"super()"，即调用父类中空参的构造器。
  5. 只会找直接父类的对应构造器，找不到就报错

> 常见错误：
>
> 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则`编译出错`。

# 关键字：static

如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）。

使用范围：

- 在Java类中，可用static修饰属性、方法、代码块、内部类

被修饰后的成员具备以下特点：

- 随着类的加载而加载
- 优先于对象存在
- 修饰的成员，被所有对象所共享
- 访问权限允许时，可不创建对象，直接被类调用



## 静态变量

语法格式：

```java
[修饰符] class 类{
	[其他修饰符] static 数据类型 变量名;
}
```

- 静态变量的默认值规则和实例变量一样。
- 静态变量值是所有对象共享。

- 静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。
- 如果权限修饰符允许，在其他类中可以通过“`类名.静态变量`”直接访问，也可以通过“`对象.静态变量`”的方式访问。
- 静态变量的`get/set`方法也静态的，当局部变量与静态变量`重名时`，使用“`类名.静态变量`”进行区分。

### 内存解析

```java
public class TestStaticVariable {
    public static void main(String[] args) {
        //静态变量total的默认值是0
        System.out.println("Employee.total = " + Employee.getTotal());

        Employee e1 = new Employee("张三");
        Employee e2 = new Employee("李四");
        System.out.println(e1);//静态变量company的默认值是null
        System.out.println(e2);//静态变量company的默认值是null
        System.out.println("Employee.total = " + Employee.getTotal());//静态变量total值是2

        Employee.company = "尚硅谷";
        System.out.println(e1);//静态变量company的值是尚硅谷
        System.out.println(e2);//静态变量company的值是尚硅谷

        //只要权限修饰符允许,虽然不推荐，但是也可以通过“对象.静态变量”的形式来访问
        e1.company = "超级尚硅谷";

        System.out.println(e1);//静态变量company的值是超级尚硅谷
        System.out.println(e2);//静态变量company的值是超级尚硅谷
    }
}
```

![image-20250202181000109](img/面向对象/image-20250202181000109.png)



## 静态方法

语法格式：

```java
[修饰符] class 类{
	[其他修饰符] static 返回值类型 方法名(形参列表){
        方法体
    }
}
```

- 静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。
- 只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用。
- 在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。
- 静态方法可以被子类继承，但不能被子类重写。
- 静态方法的调用都只看编译时类型。
- 因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。

# 关键字：final

## final 修饰类

表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。

+ 如：String类、System类、StringBuffer类

```java
final class Eunuch{//太监类
	
}
```

## final 修饰方法

表示这个方法不能被子类重写。

+ 如：Object类中的getClass()

## final 修饰变量

final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。

+ 如：final double MY_PI = 3.14;

> 如果某个成员变量用final修饰后，没有set方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值）

```java
public final class Test {
    public static int totalNumber = 5;
    public final int ID;

    public Test() {
        ID = ++totalNumber; // 可在构造器中给final修饰的“变量”赋值
    }
    public static void main(String[] args) {
        Test t = new Test();
        System.out.println(t.ID);
    }
}

```

> 排错：
>
> ```java
> public class Something {
>     public int addOne(final int x) {
>         // return ++x;
>         return x + 1;
>     }
> }
> ```
>
> ```java
> public class Something {
>     public static void main(String[] args) {
>         Other o = new Other();
>         new Something().addOne(o);
>     }
>     public void addOne(final Other o) {
>         // o = new Other();
>         o.i++;
>     }
> }
> class Other {
>     public int i;
> }
> 
> ```
>
> 

# Object类的使用

类 `java.lang.Object`是类层次结构的根类，即所有其它类的父类。每个类都使用 `Object` 作为超类。

## Object类的方法

### equals()

== ：

+ 基本类型比较值:只要两个变量的值相等，即为true。
+ 引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。
  + 用“==”进行比较时，符号两边的`数据类型必须兼容`(可自动转换的基本数据类型除外)，否则编译出错

equals()：

+ 只能比较引用类型，Object类源码中equals()的作用与“==”相同：比较是否指向同一个对象。
+ 当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象。
  + 原因：在这些类中重写了Object类的equals()方法。
+ 当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等

> **面试题：**==和equals的区别
>
> - == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址
>
> - equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。
>
> - 具体要看自定义类里有没有重写Object的equals方法来判断。
>
> - 通常情况下，重写equals方法，会比较类中的相应属性是否都相等。

### toString()

默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式"

在进行String与其它类型数据的连接操作时，自动调用toString()方法

```java
Date now=new Date();
System.out.println(“now=”+now);  //相当于
System.out.println(“now=”+now.toString()); 

// 如果直接System.out.println(对象)，默认会自动调用这个对象的toString()
```

可以根据需要在用户自定义类型中重写toString()方法，如String 类重写了toString()方法，返回字符串的值。

### clone()

创建对象的副本。它会返回一个与原对象内容相同的对象。这个副本与原对象是独立的，对副本的修改不会影响原对象。

### finalize()

- 当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，是本类对象调用的）
  - 永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。
- 当某个对象没有任何引用时，JVM就认为这个对象是垃圾对象，就会在之后不确定的时间使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize()方法。 
- 子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如，在方法内断开相关连接资源。
  - 如果重写该方法，让一个新的引用变量重新引用该对象，则会重新激活对象。
- 在JDK 9中此方法已经被`标记为过时`的。

### getClass()

获取对象的运行时类型

> 因为Java有多态现象，所以一个引用数据类型的变量的编译时类型与运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象的类型，需要用getClass()方法

### hashCode()

返回每个对象的hash值

## native关键字的理解

使用native关键字说明这个方法是原生函数，也就是这个方法是用`C/C++`等非Java语言实现的，并且`被编译成了DLL`，由Java去调用。

为什么要用native方法：

+ Java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者对程序的效率很在意时，例如：Java需要与一些底层操作系统或某些硬件交换信息时的情况。native方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。



# 单例模式

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法

## 饿汉式

```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }

    // 2.内部提供一个当前类的实例
    // 4.此实例也必须静态化
    private static Singleton single = new Singleton();

    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        return single;
    }
}

```

## 懒汉式

```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }
    // 2.内部提供一个当前类的实例
    // 4.此实例也必须静态化
    private static Singleton single;
    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        if(single == null) {
            single = new Singleton();
        }
        return single;
    }
}

```



## 饿汉式VS懒汉式

饿汉式：

- 特点：`立即加载`，即在使用类的时候已经将对象创建完毕。
- 优点：实现起来`简单`；没有多线程安全问题。
- 缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会`耗费内存`。

懒汉式：

- 特点：`延迟加载`，即在调用静态方法时实例才被创建。
- 优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会`节约内存`。
- 缺点：在多线程环境中，这种实现方法是完全错误的，`线程不安全`，根本不能保证单例的唯一性。



## 单例模式的优点及应用

由于单例模式只生成一个实例，减少了`系统性能开销`，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。

# main方法

由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。 

![image-20250202182422604](img/面向对象/image-20250202182422604.png)

# 抽象类和抽象方法

把**没有方法体**的方法称为**抽象方法**。Java语法规定，包含抽象方法的类必须是**抽象类**。

语法格式：

```java
[权限修饰符] abstract class 类名{
    [其他修饰符] abstract 返回值类型 方法名([形参列表]);
}
```

* **抽象类**：被abstract修饰的类。
* **抽象方法**：被abstract修饰没有方法体的方法。

使用说明：

1. 抽象类**不能创建对象**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。

   > 抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。

2. 抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。

   > 理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。

3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

4. 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 


# 接口

接口就是规范，定义的是一组规则，体现了现实世界中“如果你是`/`要...则必须能...”的思想。继承是一个"是不是"的is-a关系，而接口实现则是 "能不能"的`has-a`关系。

接口的定义使用 `interface` 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。

> 引用数据类型：数组，类，枚举，接口，注解。

## 接口的声明

```java
[修饰符] interface 接口名{
    //接口的成员列表：
    // 公共的静态常量
    // 公共的抽象方法
    
    // 公共的默认方法（JDK1.8以上）
    // 公共的静态方法（JDK1.8以上）
    // 私有方法（JDK1.9以上）
}
```

```java
public interface USB{
    //静态常量
    long MAX_SPEED = 500*1024*1024;//500MB/s

    //抽象方法
    void in();
    void out();

    //默认方法
    default void start(){
        System.out.println("开始");
    }
    default void stop(){
        System.out.println("结束");
    }

    //静态方法
    static void show(){
        System.out.println("USB 3.0可以同步全速地进行读写操作");
    }
}
```

## 接口的成员说明

**在JDK8.0 之前**，接口中只允许出现：

（1）公共的静态的常量：其中`public static final`可以省略

（2）公共的抽象的方法：其中`public abstract`可以省略

> 理解：接口是从多个相似类中抽象出来的规范，不需要提供具体实现

**在JDK8.0 时**，接口中允许声明`默认方法`和`静态方法`：

（3）公共的默认的方法：其中public 可以省略，建议保留，但是default不能省略

（4）公共的静态的方法：其中public 可以省略，建议保留，但是static不能省略

**在JDK9.0 时**，接口又增加了：

（5）私有方法

除此之外，接口中没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化。



## 接口的使用规则

**1、类实现接口（implements）**

接口**不能创建对象**，但是可以被类实现（`implements` ，类似于被继承），实现使用 ` implements`关键字。

语法格式：

```java

【修饰符】 class 实现类 extends 父类 implements 接口{
    // 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】,重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了
    // 接口中的静态方法不能被继承也不能被重写
}
```

**2、接口的多实现（implements）**

在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的`多实现`。并且，一个类能继承一个父类，同时实现多个接口。

语法格式：

```java
【修饰符】 class 实现类 extends 父类 implements 接口1，接口2，接口3{
}
```

> 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。**如果抽象方法有重名的，只需要重写一次**。

**3、接口的多继承(extends)**

一个接口能继承另一个或者多个接口，接口的继承也使用 `extends` 关键字，子接口继承父接口的方法。

```java
public interface UsbC extends Chargeable,USB3 {
}
```

**4、接口与实现类对象构成多态引用**

通过接口类型的变量调用方法，最终执行的是new的实现类对象实现的方法体。

**5、使用接口的静态成员**

接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。



## JDK8中相关冲突问题

### 默认方法冲突问题

**（1）类优先原则**

当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。

**（2）接口冲突（左右为难）**

当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，选择保留其中一个，通过“`接口名.super.方法名`"的方法选择保留哪个接口的默认方法。

```java
public class Girl implements Friend,BoyFriend{

    @Override
    public void date() {
        //(1)保留其中一个父接口的
//        Friend.super.date();
//        BoyFriend.super.date();
        //(2)完全重写
        System.out.println("跟康师傅学Java");
    }

}
```

当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，重写这个默认方法。

> 子接口重写默认方法时，default关键字可以保留。
>
> 子类重写默认方法时，default关键字不可以保留。

### 常量冲突问题

这些情况下 子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题：

- 子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。
- 子类同时实现多个接口，而多个接口存在相同同名常量。

```java
public class SuperClass {
    int x = 1;
}
```

```java
public interface SuperInterface {
    int x = 2;
    int y = 2;
}
```

```java
public interface MotherInterface {
    int x = 3;
}
```

```java
public class SubClass extends SuperClass implements SuperInterface,MotherInterface {
    public void method(){
//        System.out.println("x = " + x);//模糊不清
        System.out.println("super.x = " + super.x); //super.x = 1
        System.out.println("SuperInterface.x = " + SuperInterface.x); //SuperInterface.x = 2
        System.out.println("MotherInterface.x = " + MotherInterface.x); //MotherInterface.x = 3
        //没有重名问题，可以直接访问
        System.out.println("y = " + y); //y = 2
    }

    public static void main(String[] args) {
        new SubClass().method();
    }
}
```

> 排错：
>
> ```java
> interface A {
>     int x = 0;
> }
> class B {
>     int x = 1;
> }
> class C extends B implements A {
>     public void pX() {
> //        System.out.println(x); //报错
>         // 修改如下：
> //        System.out.println(A.x); //0
>         System.out.println(super.x);// 1
>     }
>     public static void main(String[] args) {
>         new C().pX();
>     }
> }
> ```
>
> 

## 关于接口的一些问题

**1、为什么接口中只能声明公共的静态的常量？**

因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。

例如：USB1.0规范中规定最大传输速率是1.5Mbps，最大输出电流是5V/500mA

​           USB3.0规范中规定最大传输速率是5Gbps(500MB/s)，最大输出电流是5V/900mA

**2、为什么JDK8.0 之后允许接口定义静态方法和默认方法呢？因为它违反了接口作为一个抽象标准定义的概念。**

`静态方法`：因为之前的标准类库设计中，有很多Collection`/`Colletions或者Path`/`Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。

`默认方法`：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。

**3、为什么JDK1.9要允许接口定义私有方法呢?**

**私有方法**：因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。

## 接口VS抽象类

![image-20250202231131344](img/面向对象/image-20250202231131344.png)

# 内部类

将一个类A定义在另一个类B里面，里面的那个类A就称为`内部类（InnerClass）`，类B则称为`外部类（OuterClass）`。

为什么需要内部类：

+ 当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。

根据内部类声明的位置，可以分为：

![image-20250202232040776](img/面向对象/image-20250202232040776.png)

## 成员内部类

如果成员内部类中不使用外部类的非静态成员，那么通常将内部类声明为静态内部类，否则声明为非静态内部类。



### 概述

语法格式：

```java
[修饰符] class 外部类{
    [其他修饰符] [static] class 内部类{
    }
}
```

**成员内部类的使用特征，概括来讲有如下两种角色：**

- 成员内部类作为`类的成员的角色`：
  - 和外部类不同，Inner class还可以声明为private或protected；
  - 可以调用外部类的结构。（注意：在静态内部类中不能使用外部类的非静态成员）
  - Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；
- 成员内部类作为`类的角色`：
  - 可以在内部定义属性、方法、构造器等结构
  - 可以继承自己的想要继承的父类，实现自己想要实现的父接口们，和外部类的父类和父接口无关
  - 可以声明为abstract类 ，因此可以被其它的内部类继承
  - 可以声明为final的，表示不能被继承
  - 编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）

注意点：

1. 外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式
2. 成员内部类可以直接使用外部类的所有成员，包括私有的数据
3. 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的

### 创建成员内部类对象

- 实例化静态内部类

```
外部类名.静态内部类名 变量 = 外部类名.静态内部类名();
变量.非静态方法();
```

- 实例化非静态内部类

```
外部类名 变量1 = new 外部类();
外部类名.非静态内部类名 变量2 = 变量1.new 非静态内部类名();
变量2.非静态方法();
```

举例：

```java
public class TestMemberInnerClass {
    public static void main(String[] args) {
        //创建静态内部类实例，并调用方法
        Outer.StaticInner inner = new Outer.StaticInner();
        inner.inFun();
        //调用静态内部类静态方法
        Outer.StaticInner.inMethod();

        System.out.println("*****************************");

        //创建非静态内部类实例（方式1），并调用方法
        Outer outer = new Outer();
        Outer.NoStaticInner inner1 = outer.new NoStaticInner();
        inner1.inFun();

        //创建非静态内部类实例（方式2）
        Outer.NoStaticInner inner2 = outer.getNoStaticInner();
        inner1.inFun();
    }
}
class Outer{
    private static String a = "外部类的静态a";
    private static String b  = "外部类的静态b";
    private String c = "外部类对象的非静态c";
    private String d = "外部类对象的非静态d";

    static class StaticInner{
        private static String a ="静态内部类的静态a";
        private String c = "静态内部类对象的非静态c";
        public static void inMethod(){
            System.out.println("Inner.a = " + a);
            System.out.println("Outer.a = " + Outer.a);
            System.out.println("b = " + b);
        }
        public void inFun(){
            System.out.println("Inner.inFun");
            System.out.println("Outer.a = " + Outer.a);
            System.out.println("Inner.a = " + a);
            System.out.println("b = " + b);
            System.out.println("c = " + c);
//            System.out.println("d = " + d);//不能访问外部类的非静态成员
        }
    }

    class NoStaticInner{
        private String a = "非静态内部类对象的非静态a";
        private String c = "非静态内部类对象的非静态c";

        public void inFun(){
            System.out.println("NoStaticInner.inFun");
            System.out.println("Outer.a = " + Outer.a);
            System.out.println("a = " + a);
            System.out.println("b = " + b);
            System.out.println("Outer.c = " + Outer.this.c);
            System.out.println("c = " + c);
            System.out.println("d = " + d);
        }
    }


    public NoStaticInner getNoStaticInner(){
        return new NoStaticInner();
    }
}
//Inner.inFun
//Outer.a = 外部类的静态a
//Inner.a = 静态内部类的静态a
//        b = 外部类的静态b
//c = 静态内部类对象的非静态c
//Inner.a = 静态内部类的静态a
//Outer.a = 外部类的静态a
//        b = 外部类的静态b
//        *****************************
//        NoStaticInner.inFun
//Outer.a = 外部类的静态a
//        a = 非静态内部类对象的非静态a
//b = 外部类的静态b
//Outer.c = 外部类对象的非静态c
//        c = 非静态内部类对象的非静态c
//d = 外部类对象的非静态d
//NoStaticInner.inFun
//Outer.a = 外部类的静态a
//        a = 非静态内部类对象的非静态a
//b = 外部类的静态b
//Outer.c = 外部类对象的非静态c
//        c = 非静态内部类对象的非静态c
//d = 外部类对象的非静态d
```

## 局部内部类

### 非匿名局部内部类

语法格式：

```java
[修饰符] class 外部类{
    [修饰符] 返回值类型  方法名(形参列表){
            [final/abstract] class 内部类{
    	}
    }    
}
```

- 编译后有自己的独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。
  - 这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类

* 和成员内部类不同的是，它前面不能有权限修饰符等
* 局部内部类如同局部变量一样，有作用域
* 局部内部类中是否能访问外部类的非静态的成员，取决于所在的方法

### 匿名局部内部类

语法格式：

```java
new 父类([实参列表]){
    重写方法...
}
```

```java
new 父接口(){
    重写方法...
}
```

举例：

```java
interface A{
	void method();
}
public class Test{
    public static void test(A a){
    	a.method();
    }
    
    public static void main(String[] args){
    	test(new A(){

			@Override
			public void method() {
				System.out.println("aaaa");
			}
    	});
    }   
}
```

# 枚举类

枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。

枚举类的实现：

- 在JDK5.0 之前，需要程序员自定义枚举类型。
- 在JDK5.0 之后，Java支持`enum`关键字来快速定义枚举类型。

## 定义枚举类

### JDK5.0之前

* `私有化`类的构造器，保证不能在类的外部创建其对象
* 在类的内部创建枚举类的实例。声明为：`public static final` ，对外暴露这些常量对象
* 对象如果有`实例变量`，应该声明为`private final`（建议，不是必须），并在构造器中初始化

```java
class Season{
    private final String SEASONNAME;//季节的名称
    private final String SEASONDESC;//季节的描述
    private Season(String seasonName,String seasonDesc){
        this.SEASONNAME = seasonName;
        this.SEASONDESC = seasonDesc;
    }
    public static final Season SPRING = new Season("春天", "春暖花开");
    public static final Season SUMMER = new Season("夏天", "夏日炎炎");
    public static final Season AUTUMN = new Season("秋天", "秋高气爽");
    public static final Season WINTER = new Season("冬天", "白雪皑皑");

    @Override
    public String toString() {
        return "Season{" +
                "SEASONNAME='" + SEASONNAME + '\'' +
                ", SEASONDESC='" + SEASONDESC + '\'' +
                '}';
    }
}
class SeasonTest{
    public static void main(String[] args) {
        System.out.println(Season.AUTUMN);
    }
}
```

### JDK5.0之后

语法格式：

```java
【修饰符】 enum 枚举类名{
    常量对象列表;
    
    对象的实例变量列表;
}
```

* 枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。
* 列出的实例系统会自动添加 public static final 修饰。
* 如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。
* 编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数
* 如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。
* 枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。
* JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。

```java
public enum SeasonEnum {
    SPRING("春天","春风又绿江南岸"),
    SUMMER("夏天","映日荷花别样红"),
    AUTUMN("秋天","秋水共长天一色"),
    WINTER("冬天","窗含西岭千秋雪");

    private final String seasonName;
    private final String seasonDesc;
    
    private SeasonEnum(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }
    public String getSeasonName() {
        return seasonName;
    }
    public String getSeasonDesc() {
        return seasonDesc;
    }
}

```

## enum中的常用方法

+ String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！
+ static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法
+ static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。
+ String name():得到当前枚举常量的名称。建议优先使用toString()。
+ int ordinal():返回当前枚举常量的次序号，默认从0开始



## 实现接口的枚举类

- 和普通 Java 类一样，枚举类可以实现一个或多个接口
- 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。
- 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法

语法格式：

```java
enum A implements 接口1，接口2{
	//抽象方法的实现
}

enum A implements 接口1，接口2{
    常量名1(参数){
        //抽象方法的实现或重写
    },
    常量名2(参数){
        //抽象方法的实现或重写
    },
    //...
}
```

# 注解

注解（Annotation）是从`JDK5.0`开始引入，以“`@注解名`”在代码中存在。

Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name=value” 对中。

注解可以在类编译、运行时进行加载，体现不同的功能。

框架 = 注解 + 反射 + 设计模式

## 注解与注释

注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解不同于单行注释和多行注释。

- 对于单行注释和多行注释是给程序员看的。
- 而注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。

## 常见的Annotation作用

+ 生成文档相关的注解

```java
@author 标明开发该类模块的作者，多个作者之间使用,分割
@version 标明该类模块的版本
@see 参考转向，也就是相关主题
@since 从哪个版本开始增加的
@param 对方法中某参数的说明，如果没有参数就不能写
@return 对方法返回值的说明，如果方法的返回值类型是void就不能写
@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写
```

+ 在编译时进行格式检查(JDK内置的三个基本注解)

```java
@Override: 限定重写父类方法，该注解只能用于方法
@Deprecated: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择
@SuppressWarnings: 抑制编译器警告
```

+ 跟踪代码依赖性，实现替代配置文件功能

如Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。



## 元注解

JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。

（1）**@Target：**用于描述注解的使用范围

* 可以通过枚举类型ElementType的10个常量对象来指定
* TYPE，METHOD，CONSTRUCTOR，PACKAGE.....

（2）**@Retention：**用于描述注解的生命周期

* 可以通过枚举类型RetentionPolicy的3个常量对象来指定
* SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）
* `唯有RUNTIME阶段才能被反射读取到`。

（3）**@Documented**：表明这个注解应该被 javadoc工具记录。

（4）**@Inherited：**允许子类继承父类中的注解



## 自定义注解

一个完整的注解应该包含三个部分：
（1）声明
（2）使用
（3）读取

语法格式：

```java
【元注解】
【修饰符】 @interface 注解名{
    【成员列表】
}
```

* 自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。
* Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组
* 可以使用 default 关键字为抽象方法指定默认返回值
* 如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value=”，所以如果注解只有一个抽象方法成员，建议使用方法名value。

读取和处理自定义注解：

+ 自定义注解必须配上注解的信息处理流程才有意义。
+ 自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。

# 包装类

## 基本数据类型对应的包装类

Java针对八种基本数据类型定义了相应的引用类型：包装类（封装类）。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。

![image-20250203171434118](img/面向对象/image-20250203171434118.png)

封装以后，内存结构对比：

```java
public static void main(String[] args){
	int num = 520;
	Integer obj = new Integer(520);
}
```

![image-20250203171516802](img/面向对象/image-20250203171516802.png)

## 自定义包装类

```java
public class MyInteger {
    int value;

    public MyInteger() {
    }

    public MyInteger(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return String.valueOf(value);
    }
}

```

## 包装类与基本数据类型间的转换

### 装箱

把基本数据类型转为包装类对象

> 转为包装类的对象，是为了使用专门为对象设计的API和特性

```java
Integer obj1 = new Integer(4);//使用构造函数函数
Float f = new Float(“4.56”);
// Long l = new Long(“asdf”);  //NumberFormatException

Integer obj2 = Integer.valueOf(4);//使用包装类中的valueOf方法
```

### 拆箱

把包装类对象拆为基本数据类型

> 转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。

从`JDK5.0 `开始，基本类型与包装类的装箱、拆箱动作可以自动完成。

```java
Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
//加法运算完成后，再次装箱，把基本数值转成对象。
```

> 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。



## 基本数据类型、包装类、字符串间的转换



基本数据类型转字符串：

+ 调用字符串重载的valueOf()方法

```java
int a = 10;
String str = String.valueOf(a);
```

+ `+""`

```java
String str = a + "";
```

字符串转基本数据类型：

+ 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型

+ 字符串转为包装类（调用 `包装类.valueof()`方法），然后可以自动拆箱为基本数据类型

> 如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。

+ 过包装类的构造器实现

```java
int a = Integer.parseInt("整数的字符串");
double d = Double.parseDouble("小数的字符串");
boolean b = Boolean.parseBoolean("true或false");

int a = Integer.valueOf("整数的字符串");
double d = Double.valueOf("小数的字符串");
boolean b = Boolean.valueOf("true或false");

int i = new Integer(“12”);

```

## 包装类对象的特点

### 包装类缓存对象

| 包装类    | 缓存对象    |
| --------- | ----------- |
| Byte      | -128~127    |
| Short     | -128~127    |
| Integer   | -128~127    |
| Long      | -128~127    |
| Float     | 没有        |
| Double    | 没有        |
| Character | 0~127       |
| Boolean   | true和false |

```java
Integer a = 1;
Integer b = 1;
System.out.println(a == b);//true

Integer i = 128;
Integer j = 128;
System.out.println(i == j);//false

Integer m = new Integer(1);//新new的在堆中
Integer n = 1;//这个用的是缓冲的常量对象，在方法区
System.out.println(m == n);//false

Integer x = new Integer(1);//新new的在堆中
Integer y = new Integer(1);//另一个新new的在堆中
System.out.println(x == y);//false

Double d1 = 1.0;
Double d2 = 1.0;
System.out.println(d1==d2);//false 比较地址，没有缓存对象，每一个都是新new的
```

### 类型转换问题

```java
Integer i = 1000;
int j = 1000;
System.out.println(i==j);//true 会自动拆箱，按照基本数据类型进行比较
```

```java
Integer i = 1000;
double j = 1000;
System.out.println(i==j);//true  会先将i自动拆箱为int，然后根据基本数据类型“自动类型转换”规则，转为double比较
```

```java
Integer i = 1;
Double d = 1.0
System.out.println(i==d);//编译报错
```

### 包装类对象不可变

```java
public class TestExam {
	public static void main(String[] args) {
		int i = 1;
		Integer j = new Integer(2);
		Circle c = new Circle();
		change(i,j,c);
		System.out.println("i = " + i);//1
		System.out.println("j = " + j);//2
		System.out.println("c.radius = " + c.radius);//10.0
	}
	
	/*
	 * 方法的参数传递机制：
	 * （1）基本数据类型：形参的修改完全不影响实参
	 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值
	 * 这类Integer等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了
	 */
	public static void change(int a ,Integer b,Circle c ){
		a += 10;
//		b += 10;//等价于  b = new Integer(b+10);
		c.radius += 10;
		/*c = new Circle();
		c.radius+=10;*/
	}
}
class Circle{
	double radius;
}
```











